{"version":3,"sources":["Map.js"],"names":["_shouldPolyfillES6Collection","require","guid","isNode","toIterator","module","exports","global","undefined","Map","KIND_KEY","KIND_VALUE","KIND_KEY_VALUE","KEY_PREFIX","SECRET_SIZE_PROP","__DEV__","OLD_IE_HASH_PREFIX","iterable","isObject","TypeError","initMap","it","next","done","value","set","key","index","getIndex","_mapData","push","setIndex","size","MapIterator","callback","thisArg","boundCallback","bind","mapData","i","length","entry","prototype","ITERATOR_SYMBOL","entries","map","kind","indexOf","Error","_map","_nextIndex","_kind","createIterResultObject","record","hash","getHash","_objectIndex","prefixedKey","_stringIndex","_otherIndex","shouldDelete","isES5","hasOwnProperty","Object","defineProperty","writable","v","console","error","get","o","e","isExtensible","getIENodeHash","node","uniqueID","nodeType","documentElement","propIsEnumerable","propertyIsEnumerable","hashProperty","hashCounter","enumerable","configurable","apply","arguments","Function"],"mappings":"AAaA;;;;;;;;AAEA,IAAMA,4BAA4B,GAAGC,OAAO,CAAC,8BAAD,CAA5C;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,iBAAD,CAAtB;;AACA,IAAMG,UAAU,GAAGH,OAAO,CAAC,YAAD,CAA1B;;AAEAI,MAAM,CAACC,OAAP,GAAkB,UAASC,MAAT,EAAiBC,SAAjB,EAA4B;AAK5C,MAAI,CAACR,4BAA4B,CAAC,KAAD,CAAjC,EAA0C;AACxC,WAAOO,MAAM,CAACE,GAAd;AACD;;AAyDD,MAAMC,QAAQ,GAAG,KAAjB;AACA,MAAMC,UAAU,GAAG,OAAnB;AACA,MAAMC,cAAc,GAAG,WAAvB;AAIA,MAAMC,UAAU,GAAG,OAAnB;AAIA,MAAIC,gBAAJ;;AACA,MAAIC,OAAJ,EAAa;AACXD,IAAAA,gBAAgB,GAAG,UAAUZ,IAAI,EAAjC;AACD;;AAGD,MAAMc,kBAAkB,GAAG,UAA3B;;AAhF4C,MAkFtCP,GAlFsC;AA4F1C,iBAAYQ,QAAZ,EAAsB;AAAA;;AACpB,UAAI,CAACC,QAAQ,CAAC,IAAD,CAAb,EAAqB;AACnB,cAAM,IAAIC,SAAJ,CAAc,wBAAd,CAAN;AACD;;AAEDC,MAAAA,OAAO,CAAC,IAAD,CAAP;;AAEA,UAAIH,QAAQ,IAAI,IAAhB,EAAsB;AACpB,YAAMI,EAAE,GAAGjB,UAAU,CAACa,QAAD,CAArB;AACA,YAAIK,IAAJ;;AACA,eAAO,CAAC,CAACA,IAAI,GAAGD,EAAE,CAACC,IAAH,EAAR,EAAmBC,IAA3B,EAAiC;AAC/B,cAAI,CAACL,QAAQ,CAACI,IAAI,CAACE,KAAN,CAAb,EAA2B;AACzB,kBAAM,IAAIL,SAAJ,CAAc,6CAAd,CAAN;AACD;;AACD,eAAKM,GAAL,CAASH,IAAI,CAACE,KAAL,CAAW,CAAX,CAAT,EAAwBF,IAAI,CAACE,KAAL,CAAW,CAAX,CAAxB;AACD;AACF;AACF;;AA7GyC;AAAA;AAAA,8BAmHlC;AACNJ,QAAAA,OAAO,CAAC,IAAD,CAAP;AACD;AArHyC;AAAA;AAAA,0BA8HtCM,GA9HsC,EA8HjC;AACP,YAAMC,KAAK,GAAGC,QAAQ,CAAC,IAAD,EAAOF,GAAP,CAAtB;AACA,eAAO,CAAC,EAAEC,KAAK,IAAI,IAAT,IAAiB,KAAKE,QAAL,CAAcF,KAAd,CAAnB,CAAR;AACD;AAjIyC;AAAA;AAAA,0BA2ItCD,GA3IsC,EA2IjCF,KA3IiC,EA2I1B;AACd,YAAIG,KAAK,GAAGC,QAAQ,CAAC,IAAD,EAAOF,GAAP,CAApB;;AAEA,YAAIC,KAAK,IAAI,IAAT,IAAiB,KAAKE,QAAL,CAAcF,KAAd,CAArB,EAA2C;AACzC,eAAKE,QAAL,CAAcF,KAAd,EAAqB,CAArB,IAA0BH,KAA1B;AACD,SAFD,MAEO;AACLG,UAAAA,KAAK,GAAG,KAAKE,QAAL,CAAcC,IAAd,CAAmB,CAACJ,GAAD,EAAMF,KAAN,CAAnB,IAAmC,CAA3C;AACAO,UAAAA,QAAQ,CAAC,IAAD,EAAOL,GAAP,EAAYC,KAAZ,CAAR;;AACA,cAAIZ,OAAJ,EAAa;AACX,iBAAKD,gBAAL,KAA0B,CAA1B;AACD,WAFD,MAEO;AACL,iBAAKkB,IAAL,IAAa,CAAb;AACD;AACF;;AAED,eAAO,IAAP;AACD;AA3JyC;AAAA;AAAA,0BAoKtCN,GApKsC,EAoKjC;AACP,YAAMC,KAAK,GAAGC,QAAQ,CAAC,IAAD,EAAOF,GAAP,CAAtB;;AACA,YAAIC,KAAK,IAAI,IAAb,EAAmB;AACjB,iBAAOnB,SAAP;AACD,SAFD,MAEO;AACL,iBAAO,KAAKqB,QAAL,CAAcF,KAAd,EAAqB,CAArB,CAAP;AACD;AACF;AA3KyC;AAAA;AAAA,8BAoLnCD,GApLmC,EAoL9B;AACV,YAAMC,KAAK,GAAGC,QAAQ,CAAC,IAAD,EAAOF,GAAP,CAAtB;;AACA,YAAIC,KAAK,IAAI,IAAT,IAAiB,KAAKE,QAAL,CAAcF,KAAd,CAArB,EAA2C;AACzCI,UAAAA,QAAQ,CAAC,IAAD,EAAOL,GAAP,EAAYlB,SAAZ,CAAR;AACA,eAAKqB,QAAL,CAAcF,KAAd,IAAuBnB,SAAvB;;AACA,cAAIO,OAAJ,EAAa;AACX,iBAAKD,gBAAL,KAA0B,CAA1B;AACD,WAFD,MAEO;AACL,iBAAKkB,IAAL,IAAa,CAAb;AACD;;AACD,iBAAO,IAAP;AACD,SATD,MASO;AACL,iBAAO,KAAP;AACD;AACF;AAlMyC;AAAA;AAAA,gCA2MhC;AACR,eAAO,IAAIC,WAAJ,CAAgB,IAAhB,EAAsBrB,cAAtB,CAAP;AACD;AA7MyC;AAAA;AAAA,6BAqNnC;AACL,eAAO,IAAIqB,WAAJ,CAAgB,IAAhB,EAAsBvB,QAAtB,CAAP;AACD;AAvNyC;AAAA;AAAA,+BA+NjC;AACP,eAAO,IAAIuB,WAAJ,CAAgB,IAAhB,EAAsBtB,UAAtB,CAAP;AACD;AAjOyC;AAAA;AAAA,8BA4OlCuB,QA5OkC,EA4OxBC,OA5OwB,EA4Of;AACzB,YAAI,OAAOD,QAAP,KAAoB,UAAxB,EAAoC;AAClC,gBAAM,IAAIf,SAAJ,CAAc,4BAAd,CAAN;AACD;;AAED,YAAMiB,aAAa,GAAGF,QAAQ,CAACG,IAAT,CAAcF,OAAO,IAAI3B,SAAzB,CAAtB;AACA,YAAM8B,OAAO,GAAG,KAAKT,QAArB;;AAKA,aAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,OAAO,CAACE,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC,cAAME,KAAK,GAAGH,OAAO,CAACC,CAAD,CAArB;;AACA,cAAIE,KAAK,IAAI,IAAb,EAAmB;AACjBL,YAAAA,aAAa,CAACK,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqB,IAArB,CAAb;AACD;AACF;AACF;AA7PyC;AAAA;AAAA;;AAiQ5ChC,EAAAA,GAAG,CAACiC,SAAJ,CAActC,UAAU,CAACuC,eAAzB,IAA4ClC,GAAG,CAACiC,SAAJ,CAAcE,OAA1D;;AAjQ4C,MAmQtCX,WAnQsC;AA4Q1C,yBAAYY,GAAZ,EAAiBC,IAAjB,EAAuB;AAAA;;AACrB,UAAI,EAAE5B,QAAQ,CAAC2B,GAAD,CAAR,IAAiBA,GAAG,CAAChB,QAAvB,CAAJ,EAAsC;AACpC,cAAM,IAAIV,SAAJ,CAAc,sBAAd,CAAN;AACD;;AAED,UAAI,CAACT,QAAD,EAAWE,cAAX,EAA2BD,UAA3B,EAAuCoC,OAAvC,CAA+CD,IAA/C,MAAyD,CAAC,CAA9D,EAAiE;AAC/D,cAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAED,WAAKC,IAAL,GAAYJ,GAAZ;AACA,WAAKK,UAAL,GAAkB,CAAlB;AACA,WAAKC,KAAL,GAAaL,IAAb;AACD;;AAxRyC;AAAA;AAAA,6BAgSnC;AACL,YAAI,CAAC,IAAD,YAAiBrC,GAArB,EAA0B;AACxB,gBAAM,IAAIU,SAAJ,CAAc,yCAAd,CAAN;AACD;;AAED,YAAM0B,GAAG,GAAG,KAAKI,IAAjB;AACA,YAAItB,KAAK,GAAG,KAAKuB,UAAjB;AACA,YAAMJ,IAAI,GAAG,KAAKK,KAAlB;;AAEA,YAAIN,GAAG,IAAI,IAAX,EAAiB;AACf,iBAAOO,sBAAsB,CAAC5C,SAAD,EAAY,IAAZ,CAA7B;AACD;;AAED,YAAMoC,OAAO,GAAGC,GAAG,CAAChB,QAApB;;AAEA,eAAOF,KAAK,GAAGiB,OAAO,CAACJ,MAAvB,EAA+B;AAC7B,cAAMa,MAAM,GAAGT,OAAO,CAACjB,KAAD,CAAtB;AAEAA,UAAAA,KAAK,IAAI,CAAT;AACA,eAAKuB,UAAL,GAAkBvB,KAAlB;;AAEA,cAAI0B,MAAJ,EAAY;AACV,gBAAIP,IAAI,KAAKpC,QAAb,EAAuB;AACrB,qBAAO0C,sBAAsB,CAACC,MAAM,CAAC,CAAD,CAAP,EAAY,KAAZ,CAA7B;AACD,aAFD,MAEO,IAAIP,IAAI,KAAKnC,UAAb,EAAyB;AAC9B,qBAAOyC,sBAAsB,CAACC,MAAM,CAAC,CAAD,CAAP,EAAY,KAAZ,CAA7B;AACD,aAFM,MAEA,IAAIP,IAAJ,EAAU;AACf,qBAAOM,sBAAsB,CAACC,MAAD,EAAS,KAAT,CAA7B;AACD;AACF;AACF;;AAED,aAAKJ,IAAL,GAAYzC,SAAZ;AAEA,eAAO4C,sBAAsB,CAAC5C,SAAD,EAAY,IAAZ,CAA7B;AACD;AAnUyC;AAAA;AAAA;;AAyU5CyB,EAAAA,WAAW,CAACS,SAAZ,CAAsBtC,UAAU,CAACuC,eAAjC,IAAoD,YAAW;AAC7D,WAAO,IAAP;AACD,GAFD;;AAeA,WAASf,QAAT,CAAkBiB,GAAlB,EAAuBnB,GAAvB,EAA4B;AAC1B,QAAIR,QAAQ,CAACQ,GAAD,CAAZ,EAAmB;AACjB,UAAM4B,IAAI,GAAGC,OAAO,CAAC7B,GAAD,CAApB;AACA,aAAOmB,GAAG,CAACW,YAAJ,CAAiBF,IAAjB,CAAP;AACD,KAHD,MAGO;AACL,UAAMG,WAAW,GAAG5C,UAAU,GAAGa,GAAjC;;AACA,UAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,eAAOmB,GAAG,CAACa,YAAJ,CAAiBD,WAAjB,CAAP;AACD,OAFD,MAEO;AACL,eAAOZ,GAAG,CAACc,WAAJ,CAAgBF,WAAhB,CAAP;AACD;AACF;AACF;;AAQD,WAAS1B,QAAT,CAAkBc,GAAlB,EAAuBnB,GAAvB,EAA4BC,KAA5B,EAAmC;AACjC,QAAMiC,YAAY,GAAGjC,KAAK,IAAI,IAA9B;;AAEA,QAAIT,QAAQ,CAACQ,GAAD,CAAZ,EAAmB;AACjB,UAAM4B,IAAI,GAAGC,OAAO,CAAC7B,GAAD,CAApB;;AACA,UAAIkC,YAAJ,EAAkB;AAChB,eAAOf,GAAG,CAACW,YAAJ,CAAiBF,IAAjB,CAAP;AACD,OAFD,MAEO;AACLT,QAAAA,GAAG,CAACW,YAAJ,CAAiBF,IAAjB,IAAyB3B,KAAzB;AACD;AACF,KAPD,MAOO;AACL,UAAM8B,WAAW,GAAG5C,UAAU,GAAGa,GAAjC;;AACA,UAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAIkC,YAAJ,EAAkB;AAChB,iBAAOf,GAAG,CAACa,YAAJ,CAAiBD,WAAjB,CAAP;AACD,SAFD,MAEO;AACLZ,UAAAA,GAAG,CAACa,YAAJ,CAAiBD,WAAjB,IAAgC9B,KAAhC;AACD;AACF,OAND,MAMO;AACL,YAAIiC,YAAJ,EAAkB;AAChB,iBAAOf,GAAG,CAACc,WAAJ,CAAgBF,WAAhB,CAAP;AACD,SAFD,MAEO;AACLZ,UAAAA,GAAG,CAACc,WAAJ,CAAgBF,WAAhB,IAA+B9B,KAA/B;AACD;AACF;AACF;AACF;;AAOD,WAASP,OAAT,CAAiByB,GAAjB,EAAsB;AAOpBA,IAAAA,GAAG,CAAChB,QAAJ,GAAe,EAAf;AAQAgB,IAAAA,GAAG,CAACW,YAAJ,GAAmB,EAAnB;AAGAX,IAAAA,GAAG,CAACa,YAAJ,GAAmB,EAAnB;AAGAb,IAAAA,GAAG,CAACc,WAAJ,GAAkB,EAAlB;;AAQA,QAAI5C,OAAJ,EAAa;AACX,UAAI8C,KAAJ,EAAW;AAIT,YAAIhB,GAAG,CAACiB,cAAJ,CAAmBhD,gBAAnB,CAAJ,EAA0C;AACxC+B,UAAAA,GAAG,CAAC/B,gBAAD,CAAH,GAAwB,CAAxB;AACD,SAFD,MAEO;AACLiD,UAAAA,MAAM,CAACC,cAAP,CAAsBnB,GAAtB,EAA2B/B,gBAA3B,EAA6C;AAC3CU,YAAAA,KAAK,EAAE,CADoC;AAE3CyC,YAAAA,QAAQ,EAAE;AAFiC,WAA7C;AAIAF,UAAAA,MAAM,CAACC,cAAP,CAAsBnB,GAAtB,EAA2B,MAA3B,EAAmC;AACjCpB,YAAAA,GAAG,EAAE,aAAAyC,CAAC,EAAI;AACRC,cAAAA,OAAO,CAACC,KAAR,CACE,iEACE,sDAFJ;AAIA,oBAAM,IAAIpB,KAAJ,CAAU,wCAAV,CAAN;AACD,aAPgC;AAQjCqB,YAAAA,GAAG,EAAE;AAAA,qBAAMxB,GAAG,CAAC/B,gBAAD,CAAT;AAAA;AAR4B,WAAnC;AAUD;;AAGD;AACD;AACF;;AAID+B,IAAAA,GAAG,CAACb,IAAJ,GAAW,CAAX;AACD;;AAQD,WAASd,QAAT,CAAkBoD,CAAlB,EAAqB;AACnB,WAAOA,CAAC,IAAI,IAAL,KAAc,OAAOA,CAAP,KAAa,QAAb,IAAyB,OAAOA,CAAP,KAAa,UAApD,CAAP;AACD;;AASD,WAASlB,sBAAT,CAAgC5B,KAAhC,EAAuCD,IAAvC,EAA6C;AAC3C,WAAO;AAACC,MAAAA,KAAK,EAALA,KAAD;AAAQD,MAAAA,IAAI,EAAJA;AAAR,KAAP;AACD;;AAGD,MAAMsC,KAAK,GAAI,YAAW;AACxB,QAAI;AACFE,MAAAA,MAAM,CAACC,cAAP,CAAsB,EAAtB,EAA0B,GAA1B,EAA+B,EAA/B;AACA,aAAO,IAAP;AACD,KAHD,CAGE,OAAOO,CAAP,EAAU;AACV,aAAO,KAAP;AACD;AACF,GAPa,EAAd;;AAeA,WAASC,YAAT,CAAsBF,CAAtB,EAAyB;AACvB,QAAI,CAACT,KAAL,EAAY;AACV,aAAO,IAAP;AACD,KAFD,MAEO;AACL,aAAOE,MAAM,CAACS,YAAP,CAAoBF,CAApB,CAAP;AACD;AACF;;AAUD,WAASG,aAAT,CAAuBC,IAAvB,EAA6B;AAC3B,QAAIC,QAAJ;;AACA,YAAQD,IAAI,CAACE,QAAb;AACE,WAAK,CAAL;AACED,QAAAA,QAAQ,GAAGD,IAAI,CAACC,QAAhB;AACA;;AACF,WAAK,CAAL;AACEA,QAAAA,QAAQ,GAAGD,IAAI,CAACG,eAAL,CAAqBF,QAAhC;AACA;;AACF;AACE,eAAO,IAAP;AARJ;;AAWA,QAAIA,QAAJ,EAAc;AACZ,aAAO3D,kBAAkB,GAAG2D,QAA5B;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF;;AAED,MAAMpB,OAAO,GAAI,YAAW;AAC1B,QAAMuB,gBAAgB,GAAGf,MAAM,CAACrB,SAAP,CAAiBqC,oBAA1C;AACA,QAAMC,YAAY,GAAG9E,IAAI,EAAzB;AACA,QAAI+E,WAAW,GAAG,CAAlB;AAQA,WAAO,SAAS1B,OAAT,CAAiBe,CAAjB,EAAoB;AAEzB,UAAIA,CAAC,CAACU,YAAD,CAAL,EAAqB;AACnB,eAAOV,CAAC,CAACU,YAAD,CAAR;AACD,OAFD,MAEO,IACL,CAACnB,KAAD,IACAS,CAAC,CAACS,oBADF,IAEAT,CAAC,CAACS,oBAAF,CAAuBC,YAAvB,CAHK,EAIL;AACA,eAAOV,CAAC,CAACS,oBAAF,CAAuBC,YAAvB,CAAP;AACD,OANM,MAMA,IAAI,CAACnB,KAAD,IAAU1D,MAAM,CAACmE,CAAD,CAAhB,IAAuBG,aAAa,CAACH,CAAD,CAAxC,EAA6C;AAClD,eAAOG,aAAa,CAACH,CAAD,CAApB;AACD,OAFM,MAEA,IAAI,CAACT,KAAD,IAAUS,CAAC,CAACU,YAAD,CAAf,EAA+B;AACpC,eAAOV,CAAC,CAACU,YAAD,CAAR;AACD;;AAED,UAAIR,YAAY,CAACF,CAAD,CAAhB,EAAqB;AACnBW,QAAAA,WAAW,IAAI,CAAf;;AACA,YAAIpB,KAAJ,EAAW;AACTE,UAAAA,MAAM,CAACC,cAAP,CAAsBM,CAAtB,EAAyBU,YAAzB,EAAuC;AACrCE,YAAAA,UAAU,EAAE,KADyB;AAErCjB,YAAAA,QAAQ,EAAE,KAF2B;AAGrCkB,YAAAA,YAAY,EAAE,KAHuB;AAIrC3D,YAAAA,KAAK,EAAEyD;AAJ8B,WAAvC;AAMD,SAPD,MAOO,IAAIX,CAAC,CAACS,oBAAN,EAA4B;AAKjCT,UAAAA,CAAC,CAACS,oBAAF,GAAyB,YAAW;AAClC,mBAAOD,gBAAgB,CAACM,KAAjB,CAAuB,IAAvB,EAA6BC,SAA7B,CAAP;AACD,WAFD;;AAGAf,UAAAA,CAAC,CAACS,oBAAF,CAAuBC,YAAvB,IAAuCC,WAAvC;AACD,SATM,MASA,IAAI9E,MAAM,CAACmE,CAAD,CAAV,EAAe;AAKpBA,UAAAA,CAAC,CAACU,YAAD,CAAD,GAAkBC,WAAlB;AACD,SANM,MAMA;AACL,gBAAM,IAAIjC,KAAJ,CAAU,oDAAV,CAAN;AACD;;AACD,eAAOiC,WAAP;AACD,OA5BD,MA4BO;AACL,cAAM,IAAIjC,KAAJ,CAAU,iDAAV,CAAN;AACD;AACF,KA/CD;AAgDD,GA3De,EAAhB;;AA6DA,SAAOvC,GAAP;AACD,CAnlBgB,CAmlBd6E,QAAQ,CAAC,aAAD,CAAR,EAnlBc,CAAjB","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @preventMunge\n * @typechecks\n */\n\n/* eslint-disable no-extend-native, no-shadow-restricted-names */\n\n'use strict';\n\nconst _shouldPolyfillES6Collection = require('_shouldPolyfillES6Collection');\nconst guid = require('guid');\nconst isNode = require('fbjs/lib/isNode');\nconst toIterator = require('toIterator');\n\nmodule.exports = (function(global, undefined) {\n  // Since our implementation is spec-compliant for the most part we can safely\n  // delegate to a built-in version if exists and is implemented correctly.\n  // Firefox had gotten a few implementation details wrong across different\n  // versions so we guard against that.\n  if (!_shouldPolyfillES6Collection('Map')) {\n    return global.Map;\n  }\n\n  /**\n   * == ES6 Map Collection ==\n   *\n   * This module is meant to implement a Map collection as described in chapter\n   * 23.1 of the ES6 specification.\n   *\n   * Map objects are collections of key/value pairs where both the keys and\n   * values may be arbitrary ECMAScript language values. A distinct key value\n   * may only occur in one key/value pair within the Map's collection.\n   *\n   * https://people.mozilla.org/~jorendorff/es6-draft.html#sec-map-objects\n   *\n   * There only two -- rather small -- diviations from the spec:\n   *\n   * 1. The use of frozen objects as keys.\n   *    We decided not to allow and simply throw an error. The reason being is\n   *    we store a \"hash\" on the object for fast access to it's place in the\n   *    internal map entries.\n   *    If this turns out to be a popular use case it's possible to implement by\n   *    overiding `Object.freeze` to store a \"hash\" property on the object\n   *    for later use with the map.\n   *\n   * 2. The `size` property on a map object is a regular property and not a\n   *    computed property on the prototype as described by the spec.\n   *    The reason being is that we simply want to support ES3 environments\n   *    which doesn't implement computed properties.\n   *\n   * == Usage ==\n   *\n   * var map = new Map(iterable);\n   *\n   * map.set(key, value);\n   * map.get(key); // value\n   * map.has(key); // true\n   * map.delete(key); // true\n   *\n   * var iterator = map.keys();\n   * iterator.next(); // {value: key, done: false}\n   *\n   * var iterator = map.values();\n   * iterator.next(); // {value: value, done: false}\n   *\n   * var iterator = map.entries();\n   * iterator.next(); // {value: [key, value], done: false}\n   *\n   * map.forEach(function(value, key){ this === thisArg }, thisArg);\n   *\n   * map.clear(); // resets map.\n   */\n\n  /**\n   * Constants\n   */\n\n  // Kinds of map iterations 23.1.5.3\n  const KIND_KEY = 'key';\n  const KIND_VALUE = 'value';\n  const KIND_KEY_VALUE = 'key+value';\n\n  // In older browsers we can't create a null-prototype object so we have to\n  // defend against key collisions with built-in methods.\n  const KEY_PREFIX = '$map_';\n\n  // This property will be used as the internal size variable to disallow\n  // writing and to issue warnings for writings in development.\n  let SECRET_SIZE_PROP;\n  if (__DEV__) {\n    SECRET_SIZE_PROP = '$size' + guid();\n  }\n\n  // In oldIE we use the DOM Node `uniqueID` property to get create the hash.\n  const OLD_IE_HASH_PREFIX = 'IE_HASH_';\n\n  class Map {\n    /**\n     * 23.1.1.1\n     * Takes an `iterable` which is basically any object that implements a\n     * Symbol.iterator (@@iterator) method. The iterable is expected to be a\n     * collection of pairs. Each pair is a key/value pair that will be used\n     * to instantiate the map.\n     *\n     * @param {*} iterable\n     */\n    constructor(iterable) {\n      if (!isObject(this)) {\n        throw new TypeError('Wrong map object type.');\n      }\n\n      initMap(this);\n\n      if (iterable != null) {\n        const it = toIterator(iterable);\n        let next;\n        while (!(next = it.next()).done) {\n          if (!isObject(next.value)) {\n            throw new TypeError('Expected iterable items to be pair objects.');\n          }\n          this.set(next.value[0], next.value[1]);\n        }\n      }\n    }\n\n    /**\n     * 23.1.3.1\n     * Clears the map from all keys and values.\n     */\n    clear() {\n      initMap(this);\n    }\n\n    /**\n     * 23.1.3.7\n     * Check if a key exists in the collection.\n     *\n     * @param {*} key\n     * @return {boolean}\n     */\n    has(key) {\n      const index = getIndex(this, key);\n      return !!(index != null && this._mapData[index]);\n    }\n\n    /**\n     * 23.1.3.9\n     * Adds a key/value pair to the collection.\n     *\n     * @param {*} key\n     * @param {*} value\n     * @return {map}\n     */\n    set(key, value) {\n      let index = getIndex(this, key);\n\n      if (index != null && this._mapData[index]) {\n        this._mapData[index][1] = value;\n      } else {\n        index = this._mapData.push([key, value]) - 1;\n        setIndex(this, key, index);\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] += 1;\n        } else {\n          this.size += 1;\n        }\n      }\n\n      return this;\n    }\n\n    /**\n     * 23.1.3.6\n     * Gets a value associated with a key in the collection.\n     *\n     * @param {*} key\n     * @return {*}\n     */\n    get(key) {\n      const index = getIndex(this, key);\n      if (index == null) {\n        return undefined;\n      } else {\n        return this._mapData[index][1];\n      }\n    }\n\n    /**\n     * 23.1.3.3\n     * Delete a key/value from the collection.\n     *\n     * @param {*} key\n     * @return {boolean} Whether the key was found and deleted.\n     */\n    delete(key) {\n      const index = getIndex(this, key);\n      if (index != null && this._mapData[index]) {\n        setIndex(this, key, undefined);\n        this._mapData[index] = undefined;\n        if (__DEV__) {\n          this[SECRET_SIZE_PROP] -= 1;\n        } else {\n          this.size -= 1;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * 23.1.3.4\n     * Returns an iterator over the key/value pairs (in the form of an Array) in\n     * the collection.\n     *\n     * @return {MapIterator}\n     */\n    entries() {\n      return new MapIterator(this, KIND_KEY_VALUE);\n    }\n\n    /**\n     * 23.1.3.8\n     * Returns an iterator over the keys in the collection.\n     *\n     * @return {MapIterator}\n     */\n    keys() {\n      return new MapIterator(this, KIND_KEY);\n    }\n\n    /**\n     * 23.1.3.11\n     * Returns an iterator over the values pairs in the collection.\n     *\n     * @return {MapIterator}\n     */\n    values() {\n      return new MapIterator(this, KIND_VALUE);\n    }\n\n    /**\n     * 23.1.3.5\n     * Iterates over the key/value pairs in the collection calling `callback`\n     * with [value, key, map]. An optional `thisArg` can be passed to set the\n     * context when `callback` is called.\n     *\n     * @param {function} callback\n     * @param {?object} thisArg\n     */\n    forEach(callback, thisArg) {\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be callable.');\n      }\n\n      const boundCallback = callback.bind(thisArg || undefined);\n      const mapData = this._mapData;\n\n      // Note that `mapData.length` should be computed on each iteration to\n      // support iterating over new items in the map that were added after the\n      // start of the iteration.\n      for (let i = 0; i < mapData.length; i++) {\n        const entry = mapData[i];\n        if (entry != null) {\n          boundCallback(entry[1], entry[0], this);\n        }\n      }\n    }\n  }\n\n  // 23.1.3.12\n  Map.prototype[toIterator.ITERATOR_SYMBOL] = Map.prototype.entries;\n\n  class MapIterator {\n    /**\n     * 23.1.5.1\n     * Create a `MapIterator` for a given `map`. While this class is private it\n     * will create objects that will be passed around publicily.\n     *\n     * @param {map} map\n     * @param {string} kind\n     */\n    constructor(map, kind) {\n      if (!(isObject(map) && map._mapData)) {\n        throw new TypeError('Object is not a map.');\n      }\n\n      if ([KIND_KEY, KIND_KEY_VALUE, KIND_VALUE].indexOf(kind) === -1) {\n        throw new Error('Invalid iteration kind.');\n      }\n\n      this._map = map;\n      this._nextIndex = 0;\n      this._kind = kind;\n    }\n\n    /**\n     * 23.1.5.2.1\n     * Get the next iteration.\n     *\n     * @return {object}\n     */\n    next() {\n      if (!this instanceof Map) {\n        throw new TypeError('Expected to be called on a MapIterator.');\n      }\n\n      const map = this._map;\n      let index = this._nextIndex;\n      const kind = this._kind;\n\n      if (map == null) {\n        return createIterResultObject(undefined, true);\n      }\n\n      const entries = map._mapData;\n\n      while (index < entries.length) {\n        const record = entries[index];\n\n        index += 1;\n        this._nextIndex = index;\n\n        if (record) {\n          if (kind === KIND_KEY) {\n            return createIterResultObject(record[0], false);\n          } else if (kind === KIND_VALUE) {\n            return createIterResultObject(record[1], false);\n          } else if (kind) {\n            return createIterResultObject(record, false);\n          }\n        }\n      }\n\n      this._map = undefined;\n\n      return createIterResultObject(undefined, true);\n    }\n  }\n\n  // We can put this in the class definition once we have computed props\n  // transform.\n  // 23.1.5.2.2\n  MapIterator.prototype[toIterator.ITERATOR_SYMBOL] = function() {\n    return this;\n  };\n\n  /**\n   * Helper Functions.\n   */\n\n  /**\n   * Return an index to map.[[MapData]] array for a given Key.\n   *\n   * @param {map} map\n   * @param {*} key\n   * @return {?number}\n   */\n  function getIndex(map, key) {\n    if (isObject(key)) {\n      const hash = getHash(key);\n      return map._objectIndex[hash];\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        return map._stringIndex[prefixedKey];\n      } else {\n        return map._otherIndex[prefixedKey];\n      }\n    }\n  }\n\n  /**\n   * Setup an index that refer to the key's location in map.[[MapData]].\n   *\n   * @param {map} map\n   * @param {*} key\n   */\n  function setIndex(map, key, index) {\n    const shouldDelete = index == null;\n\n    if (isObject(key)) {\n      const hash = getHash(key);\n      if (shouldDelete) {\n        delete map._objectIndex[hash];\n      } else {\n        map._objectIndex[hash] = index;\n      }\n    } else {\n      const prefixedKey = KEY_PREFIX + key;\n      if (typeof key === 'string') {\n        if (shouldDelete) {\n          delete map._stringIndex[prefixedKey];\n        } else {\n          map._stringIndex[prefixedKey] = index;\n        }\n      } else {\n        if (shouldDelete) {\n          delete map._otherIndex[prefixedKey];\n        } else {\n          map._otherIndex[prefixedKey] = index;\n        }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a map with internal slots.\n   *\n   * @param {map} map\n   */\n  function initMap(map) {\n    // Data structure design inspired by Traceur's Map implementation.\n    // We maintain an internal array for all the entries. The array is needed\n    // to remember order. However, to have a reasonable HashMap performance\n    // i.e. O(1) for insertion, deletion, and retrieval. We maintain indices\n    // in objects for fast look ups. Indices are split up according to data\n    // types to avoid collisions.\n    map._mapData = [];\n\n    // Object index maps from an object \"hash\" to index. The hash being a unique\n    // property of our choosing that we associate with the object. Association\n    // is done by ways of keeping a non-enumerable property on the object.\n    // Ideally these would be `Object.create(null)` objects but since we're\n    // trying to support ES3 we'll have to guard against collisions using\n    // prefixes on the keys rather than rely on null prototype objects.\n    map._objectIndex = {};\n\n    // String index maps from strings to index.\n    map._stringIndex = {};\n\n    // Numbers, booleans, undefined, and null.\n    map._otherIndex = {};\n\n    // Unfortunately we have to support ES3 and cannot have `Map.prototype.size`\n    // be a getter method but just a regular method. The biggest problem with\n    // this is safety. Clients can change the size property easily and possibly\n    // without noticing (e.g. `if (map.size = 1) {..}` kind of typo). What we\n    // can do to mitigate use getters and setters in development to disallow\n    // and issue a warning for changing the `size` property.\n    if (__DEV__) {\n      if (isES5) {\n        // If the `SECRET_SIZE_PROP` property is already defined then we're not\n        // in the first call to `initMap` (e.g. coming from `map.clear()`) so\n        // all we need to do is reset the size without defining the properties.\n        if (map.hasOwnProperty(SECRET_SIZE_PROP)) {\n          map[SECRET_SIZE_PROP] = 0;\n        } else {\n          Object.defineProperty(map, SECRET_SIZE_PROP, {\n            value: 0,\n            writable: true,\n          });\n          Object.defineProperty(map, 'size', {\n            set: v => {\n              console.error(\n                'PLEASE FIX ME: You are changing the map size property which ' +\n                  'should not be writable and will break in production.',\n              );\n              throw new Error('The map size property is not writable.');\n            },\n            get: () => map[SECRET_SIZE_PROP],\n          });\n        }\n\n        // NOTE: Early return to implement immutable `.size` in DEV.\n        return;\n      }\n    }\n\n    // This is a diviation from the spec. `size` should be a getter on\n    // `Map.prototype`. However, we have to support IE8.\n    map.size = 0;\n  }\n\n  /**\n   * Check if something is an object.\n   *\n   * @param {*} o\n   * @return {boolean}\n   */\n  function isObject(o) {\n    return o != null && (typeof o === 'object' || typeof o === 'function');\n  }\n\n  /**\n   * Create an iteration object.\n   *\n   * @param {*} value\n   * @param {boolean} done\n   * @return {object}\n   */\n  function createIterResultObject(value, done) {\n    return {value, done};\n  }\n\n  // Are we in a legit ES5 environment. Spoiler alert: that doesn't include IE8.\n  const isES5 = (function() {\n    try {\n      Object.defineProperty({}, 'x', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  })();\n\n  /**\n   * Check if an object can be extended.\n   *\n   * @param {object|array|function|regexp} o\n   * @return {boolean}\n   */\n  function isExtensible(o) {\n    if (!isES5) {\n      return true;\n    } else {\n      return Object.isExtensible(o);\n    }\n  }\n\n  /**\n   * IE has a `uniqueID` set on every DOM node. So we construct the hash from\n   * this uniqueID to avoid memory leaks and the IE cloneNode bug where it\n   * clones properties in addition to the attributes.\n   *\n   * @param {object} node\n   * @return {?string}\n   */\n  function getIENodeHash(node) {\n    let uniqueID;\n    switch (node.nodeType) {\n      case 1: // Element\n        uniqueID = node.uniqueID;\n        break;\n      case 9: // Document\n        uniqueID = node.documentElement.uniqueID;\n        break;\n      default:\n        return null;\n    }\n\n    if (uniqueID) {\n      return OLD_IE_HASH_PREFIX + uniqueID;\n    } else {\n      return null;\n    }\n  }\n\n  const getHash = (function() {\n    const propIsEnumerable = Object.prototype.propertyIsEnumerable;\n    const hashProperty = guid();\n    let hashCounter = 0;\n\n    /**\n     * Get the \"hash\" associated with an object.\n     *\n     * @param {object|array|function|regexp} o\n     * @return {number}\n     */\n    return function getHash(o) {\n      // eslint-disable-line no-shadow\n      if (o[hashProperty]) {\n        return o[hashProperty];\n      } else if (\n        !isES5 &&\n        o.propertyIsEnumerable &&\n        o.propertyIsEnumerable[hashProperty]\n      ) {\n        return o.propertyIsEnumerable[hashProperty];\n      } else if (!isES5 && isNode(o) && getIENodeHash(o)) {\n        return getIENodeHash(o);\n      } else if (!isES5 && o[hashProperty]) {\n        return o[hashProperty];\n      }\n\n      if (isExtensible(o)) {\n        hashCounter += 1;\n        if (isES5) {\n          Object.defineProperty(o, hashProperty, {\n            enumerable: false,\n            writable: false,\n            configurable: false,\n            value: hashCounter,\n          });\n        } else if (o.propertyIsEnumerable) {\n          // Since we can't define a non-enumerable property on the object\n          // we'll hijack one of the less-used non-enumerable properties to\n          // save our hash on it. Addiotionally, since this is a function it\n          // will not show up in `JSON.stringify` which is what we want.\n          o.propertyIsEnumerable = function() {\n            return propIsEnumerable.apply(this, arguments);\n          };\n          o.propertyIsEnumerable[hashProperty] = hashCounter;\n        } else if (isNode(o)) {\n          // At this point we couldn't get the IE `uniqueID` to use as a hash\n          // and we couldn't use a non-enumerable property to exploit the\n          // dontEnum bug so we simply add the `hashProperty` on the node\n          // itself.\n          o[hashProperty] = hashCounter;\n        } else {\n          throw new Error('Unable to set a non-enumerable property on object.');\n        }\n        return hashCounter;\n      } else {\n        throw new Error('Non-extensible objects are not allowed as keys.');\n      }\n    };\n  })();\n\n  return Map;\n})(Function('return this')()); // eslint-disable-line no-new-func\n"]}